import yaml
import copy
import importlib
import sys
import os
import errno
import subprocess
import time

from pprint import pprint
from kubernetes import client, config, watch
from kubernetes.client.rest import ApiException
from adjust import Adjust, AdjustError

# functions from servo-k8s




# new functinos for rollout
def get_object(api, group, version, namespace, plural, name):
    """
    read an object (get_namespaced_custom_object)
    returns: resource_object (e.g. spec.template.spec)
    raises: ApiException
    """

    try:
        resource = api.get_namespaced_custom_object(
            group, version, namespace, plural, name,
        )
        # print("Initial Resource details:")
        # pprint(resource)
        return resource

    except ApiException as e:
        print(
            "Exception when calling CustomObjectsApi->get_namespaced_custom_object: %s\n"
            % e
        )


def patch_object(api, group, version, namespace, plural, name, body):
    """
    patch an object (patch_namespaced_custom_object)
    returns: changing on success
    raises: ApiException
    """

    try:
        resource = api.patch_namespaced_custom_object(
            group, version, namespace, plural, name, body,
        )
        return True

    except ApiException as e:
        print(
            "Exception when calling CustomObjectsApi->patch_namespaced_custom_object: %s\n"
            % e
        )


def watch_object(api, group, version, namespace, plural, name, changing):
    """
    patch an object (patch_namespaced_custom_object)
    returns: rollout-selector
    raises: ApiException
    """

    while changing is True:
        try:
            # print("Resource list:")
            resource_list = api.list_namespaced_custom_object(
                group,
                version,
                namespace,
                plural,
                watch=False,
                label_selector="app=web",
            )
            # pprint(resource_list)
            # print("Resource list status:")
            active_selector = {
                "active": resource_list["items"][0]["status"]["blueGreen"][
                    "activeSelector"
                ]
            }
            if (
                resource_list["items"][0]["status"]["blueGreen"]["activeSelector"]
                == resource_list["items"][0]["status"]["blueGreen"]["previewSelector"]
            ):
                changing = False
                print("Change completed")
                return active_selector
                break

            print("Resource status:")
            pprint(resource_list["items"][0]["status"]["blueGreen"]["activeSelector"])

        except ApiException as e:
            print(
                "Exception when calling CustomObjectsApi->list_namespaced_custom_object: %s\n"
                % e
            )
        time.sleep(watch_timeout)


# DESCRIBE, and ensure rollout object will autopromote


def query(servo_conifg):
    # api, group, version, namespace, plural, name
    #config.load_kube_config()
    config.load_incluster_config()

    api = client.CustomObjectsApi()

    patch_autopromote = {
        "spec": {"strategy": {"blueGreen": {"autoPromotionEnabled": True, }}}
    }

    # Timeout for watch loop in seconds
    watch_timeout = servo_config["watch_timeout"]

    # set to true after an adjustment
    changing = False

    # rollout namespaced object requirements
    group = "argoproj.io"
    version = "v1alpha1"
    plural = "rollouts"

    name = servo_config["name"]
    namespace = servo_config["namespace"]
    container_name = servo_config["container_name"]

    object = get_object(api, group, version, namespace, plural, name)
    
    # First let's ensure that we will auto-promote changes
    body = {
        "spec": {"strategy": {"blueGreen": {"autoPromotionEnabled": True,}}}
    }
    changing = patch_object(api, group, version, namespace, plural, name, body)
    watch_object(api, group, version, namespace, plural, name, changing)

    # determine which container to update
    container_index = 0
    for n in object["spec"]["template"]["spec"]["containers"]:
        if container_name == n["name"]:
            break
        container_index += 1

    # get the container template
    app = object["spec"]["template"]["spec"]["containers"][container_index]

    state={}
    state.update({replicas: object["spec"]["replicas"]})
    state.update({cpu: app['resources']['limit']['cpu']})
    state.update({mem: app['resources']['limit']['cpu']})

    return state


# ADJUST
def adjust(api, group, version, namespace, plural, name):
    config.load_incluster_config()

    api = client.CustomObjectsApi()

    patch_autopromote = {
        "spec": {"strategy": {"blueGreen": {"autoPromotionEnabled": True, }}}
    }

    # Timeout for watch loop in seconds
    watch_timeout = servo_config["watch_timeout"]

    # set to true after an adjustment
    changing = False

    # rollout namespaced object requirements
    group = "argoproj.io"
    version = "v1alpha1"
    plural = "rollouts"

    name = servo_config["name"]
    namespace = servo_config["namespace"]
    container_name = servo_config["container_name"]

    object = get_object(api, group, version, namespace, plural, name)

    # determine which container to update
    container_index = 0
    for n in object["spec"]["template"]["spec"]["containers"]:
        if container_name == n["name"]:
            break
        container_index += 1

    # get the container template
    app = object["spec"]["template"]["spec"]["containers"][container_index]

    # example of updating application arguments
    # new_args = ['busy = ' + busy_param]
    # app['args'] = new_args

    # Update resource limits
    new_limits = {
        "limits": {"cpu": cpu, "memory": mem},
        "requests": {"cpu": cpu, "memory": mem},
    }
    app["resources"].update(new_limits)

    # Update replica count
    object["spec"]["replicas"] = replicas
    object["spec"]["template"]["spec"]["containers"][container_index].update(app)

    changing = patch_object(api, group, version, namespace, plural, name, body)
    watch_object(api, group, version, namespace, plural, name, changing)

def read_config():
    servo_config = yaml.safe_load(open("config.yaml"))["rollouts"]
    return servo_config


def import_encoder_base():
    try:
        return importlib.import_module('encoders.base')
    except ImportError:
        raise ImportError(
            'Unable to import base for encoders when handling `command` section.')


def cpuunits(s):
    '''convert a string for CPU resource (with optional unit suffix) into a number'''
    if s[-1] == "m":  # there are no units other than 'm' (millicpu)
        return float(s[:-1])/1000.0
    return float(s)


# valid mem units: E, P, T, G, M, K, Ei, Pi, Ti, Gi, Mi, Ki
# nb: 'm' suffix found after setting 0.7Gi
mumap = {"E": 1000**6,  "P": 1000**5,  "T": 1000**4,  "G": 1000**3,  "M": 1000**2,  "K": 1000, "m": 1000**-1,
         "Ei": 1024**6, "Pi": 1024**5, "Ti": 1024**4, "Gi": 1024**3, "Mi": 1024**2, "Ki": 1024}


def memunits(s):
    '''convert a string for memory resource (with optional unit suffix) into a number'''
    for u, m in mumap.items():
        if s.endswith(u):
            return float(s[:-len(u)]) * m
    return float(s)


def encoder_setting_name(setting_name, encoder_config):
    prefix = encoder_config['setting_prefix'] if 'setting_prefix' in encoder_config else ''
    return '{}{}'.format(prefix, setting_name)


def describe_encoder(value, config, exception_context='a describe phase of an encoder'):
    encoder_base = import_encoder_base()
    try:
        settings = encoder_base.describe(config, value or '')
        for name, setting in settings.items():
            yield (encoder_setting_name(name, config), setting)
    except BaseException as e:
        raise Exception('Error while handling {}: {}'.format(
            exception_context, str(e)))


def encode_encoder(settings, config, expected_type=None, exception_context='an encode phase of an encoder'):
    encoder_base = import_encoder_base()
    try:
        sanitized_settings = settings
        prefix = config.get('setting_prefix')
        if prefix:
            sanitized_settings = dict(map(lambda i: (i[0].lstrip(prefix), i[1]),
                                          filter(lambda i: i[0].startswith(prefix), settings.items())))
        encoded_value, encoded_settings = encoder_base.encode(
            config, sanitized_settings, expected_type=expected_type)
        encoded_settings = list(map(lambda setting_name: encoder_setting_name(
            setting_name, config), encoded_settings))
        return encoded_value, encoded_settings
    except BaseException as e:
        raise Exception('Error while handling {}: {}'.format(
            exception_context, str(e)))

class RolloutAdjust(Adjust):

    def _progress(self, progress, message):
        """adapter for the default base class implementation of progress message"""
        self.progress = progress
        self.print_progress(message=message)

    def query(self):
        try:
            servo_config = read_config()
        except ConfigError as e:
            # maybe we should introduce reason=config (or even a different status class, instead of 'failed')
            raise AdjustError(str(e), reason="unknown")
        r = query(servo_config)
        return r

    def adjust(self, data):
        try:
            desc = read_desc()
        except ConfigError as e:
            # maybe we should introduce reason=config (or even a different status class, instead of 'failed')
            raise AdjustError(str(e), reason="unknown")
        # all other exceptions: default handler - stack trace and sys.exit(1)
        r = update(namespace, desc, data, self._progress)
        return r


if __name__ == "__main__":
 
    name = servo_config["name"]
    namespace = servo_config["namespace"]
    container_name = servo_config["container_name"]

    RolloutAdjust(
        VERSION,
        "Argo Rollouts driver for Opsani servo.\n"
        "Note: set OPTUNE_USE_DEFAULT_NAMESPACE=1 environment variable in the servo",
        supports_cancel=False,
        progress_interval=None).run()




"""
Pseudo code:

1) ensure that the rollout object exists, and get the current parameters (e.g. as per deployment)
    cpu
    memory
    replicas
    vars
2) ensure rollouts are set to autopromote
3) get the current rollout state
4) support describe function based on the above state

5) get adjust parameters
6) patch rollout resource
7) wait for resource to promote to production
   a) deal with rollout failure and rollback (?)
   return "reject"
   b) check to see if activeSelector and previewSelector are the same (complete)
   return "success"
"""
